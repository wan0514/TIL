**왜 기존 값이 위로 올라오고, 아래 컴포넌트는 빈값일까?** 이걸 파헤쳐보자.

---

## 🧪 실험 상황 다시 정리

예를 들어 비정상 버전(즉 `key={index}`)에서 우리가 입력창에 값을 이렇게 넣었다고 해보자:

- `A`에 "aaa"
- `B`에 "bbb"
- `C`에 "ccc"

그리고 `Add Item`을 눌러서 `F`가 맨 위에 추가되면, 리스트는 이렇게 바뀜:

```
[F, A, B, C] ← 새 배열 상태
```

---

## 💣 문제 핵심: key={index}는 위치에 따라 키가 바뀐다

`map((item, index) => <ListItem key={index} ... />)`를 쓰면, React는 **렌더링 순서(index)**를 기준으로 컴포넌트를 식별해.

버튼을 누르기 전:

| Index | Text | Key |
|-------|------|-----|
| 0     | A    | 0   |
| 1     | B    | 1   |
| 2     | C    | 2   |

버튼 누른 후:

| Index | Text | Key |
|-------|------|-----|
| 0     | F    | 0   |
| 1     | A    | 1   |
| 2     | B    | 2   |
| 3     | C    | 3   |

---

## 🔄 React의 입장에서 일어나는 일

React는 **"이전에 key=0이었던 컴포넌트를 다시 써야지!"** 라고 생각함.  
그런데 key=0이었던 건 `A`였고, 지금 key=0인 건 `F`임.

즉, React는:

- `F`라는 텍스트지만 `A` 컴포넌트를 재사용해서 `F`로 바꿈
- 그래서 `A`에 입력했던 "aaa"가 그대로 위로 따라감 (컴포넌트 재사용됨)
- 반대로 진짜 `A`는 아래로 밀려서 index=1이 되었는데, **이건 React가 새로 만든 컴포넌트**라서 input 값은 초기화됨 (빈값)

---

## 📦 요약하면

- key={index} → 위치에 따라 컴포넌트를 식별함
- 요소가 앞에 추가되면, key들이 전부 밀림
- 그 결과, **컴포넌트는 잘못 재사용**되고
- **상태(useState로 만든 값)** 도 엉뚱한 항목에 붙음

---

## 🧠 핵심 정리

| 정리 항목        | 설명 |
|------------------|------|
| key={index}의 문제 | 위치가 바뀌면 다른 걸 같은 컴포넌트라고 착각함 |
| 왜 상태가 엉킴?   | 컴포넌트를 잘못 재사용하면서 상태도 같이 이동함 |
| 해결법            | 항상 고유한 key(id 등)를 주면 위치가 바뀌어도 잘 식별함 |

## 만약 새로운 요소가 마지막에 추가되는 기획이라면?

물론 그 경우에는 에러가 일어나지 않을 수도 있지만, sort나 다른 사이드 이팩트가 존재한다면 이 역시 의도하지 않은 값이 들어갈 가능성이 있다. 따라서 고유한 key를 주는 것이 올바른 방식이다.