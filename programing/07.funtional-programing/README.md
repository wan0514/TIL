# 함수형 프로그래밍

순수 함수(pure function)를 기반으로 상태 변경을 최소화하며 선언적으로 코드를 작성하는 방식을 말한다.

함수형 프로그래밍의 핵심요소는 다음과 같다.

- 순수함수
- 불변성
- 참조투명성
- 일급함수
- 고차함수
- 선언형 프로그래밍
- 합성

## 🧐 함수형 프로그래밍을 왜 사용할까?

- 버그 감소 → 부수 효과를 줄여서 예측 가능한 코드 작성
- 가독성 증가 → 선언형 스타일로 읽기 쉬운 코드 작성
- 테스트 용이 → 순수 함수 기반이라 유닛 테스트가 쉬움
- 병렬 처리 효율적 → 불변성을 유지하면 여러 스레드에서 동시에 안전하게 실행 가능
- 자바스크립트는 함수형 프로그래밍을 지원하는 언어야. 네가 이미 사용하고 있는 map,filter, reduce 같은 함수도 함수형 프로그래밍 개념에서 온 거야! 👍

## 순수 함수란

- 같은 입력이 주어지면 항상 같은 출력을 반환해야 한다.
- 부수 효과(side effect)가 없어야 한다.(예: 전역 변수 변경, I/O, 데이터베이스 접근 등).

## 불변성

- 데이터(객체, 배열 등)를 직접 수정하지 않고, 복사본을 만들어 변경하는 방식으로 처리한다..
- map, filter, reduce 같은 메서드를 활용해 불변성을 유지하면서 데이터를 가공한다..

## 참조투명성

참조 투명성은 동일한 입력에 대해 항상 동일한 출력을 보장하는 특성을 의미한다.
즉, 함수를 실행할 때 같은 인자가 들어오면 언제나 같은 결과가 나와야 한다는 개념.

> 🔹 "같은 값을 가지는 표현식은 언제든 교체(치환)될 수 있어야 한다."

이게 왜 중요하냐면, 참조 투명성이 유지되면 코드를 예측하기 쉬워지고, 디버깅과 테스트가 쉬워진다. 또한, 병렬 처리나 캐싱에도 유리하다.

## 선언형 프로그래밍(Declarative Programming)

선언형 프로그래밍은 "어떻게(how)"가 아니라 "무엇을(what)" 할지를 명확하게 표현하는 방식이다.

> 🔹 즉, 로직의 흐름을 직접 제어하지 않고, 원하는 결과를 기술하는 방식

### 🔸 선언형 vs 명령형 프로그래밍의 차이

- 명령형 프로그래밍(Imperative Programming)은 단계별로 어떻게 동작할지를 명확히 명시하는 방식이다.
- 반면, 선언형 프로그래밍은 결과를 중심으로 코드가 표현되며 내부 구현을 신경 쓰지 않는 방식이다.

## 클로저 & 람다

**클로저(Closure)**와 **람다(Lambda)**는 자주 혼용되지만, 실제로 서로 다른 개념입니다. 간략하게 각각 설명하겠습니다.

### 1. 클로저 (Closure)

클로저는 함수와 그 함수가 선언된 환경(스코프)을 기억하는 기능을 말합니다. 즉, 함수가 외부 함수의 변수에 접근할 수 있는 특성을 의미합니다. 클로저를 사용하면 외부 함수가 실행된 후에도 내부 함수에서 외부 함수의 변수를 참조할 수 있습니다.

예시:

```javascript
function outer() {
  let count = 0;

  return function inner() {
    count++;
    console.log(count);
  };
}

const increment = outer();
increment(); // 1
increment(); // 2
```

여기서 `inner` 함수는 `outer` 함수의 `count` 변수를 클로저를 통해 참조하고 있습니다.

### 2. 람다 (Lambda)

람다는 "익명 함수" 또는 "화살표 함수"로 이해할 수 있습니다. 람다는 이름 없는 함수로, 특히 함수가 간단하거나 다른 함수에 인자로 전달될 때 유용합니다. 람다 함수는 자주 `=>` 문법을 사용하여 정의됩니다.

예시:

```javascript
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5
```

이와 같이, 람다 함수는 간결한 문법으로 정의되고, 자주 콜백 함수나 함수형 프로그래밍에서 사용됩니다.

### 차이점:

- **클로저**는 함수가 외부 변수에 접근할 수 있는 특성입니다.
- **람다**는 간결한 함수 정의 방식이며, 주로 `=>` 문법을 사용합니다. 람다는 클로저를 사용할 수 있지만, 람다 자체가 클로저는 아닙니다. 람다도 클로저의 역할을 할 수 있습니다.

즉, 람다 함수는 함수 정의 방법이고, 클로저는 함수와 스코프와의 관계입니다.

# 어떻게 학습할까?

이렇게 사고하면 함수형 프로그래밍 학습이 된다

- 큰 문제를 작은 함수로 나눈다 (각 판별 함수 만들기)
- 클로저를 활용해서 불필요한 연산을 피한다 (createClassifier로 한 번 계산)
- 고차함수를 적극 활용해서 선언형으로 처리한다 (map(), filter(), join())
- 불변성을 유지하고 부작용을 최소화한다 (모든 함수는 순수 함수)

## 학습하면서 헷갈렸던 부분 정리

#### 1. 함수가 내부에서 다른 함수를 호출하는 것과 의존성(Dependency)의 차이

다른 함수를 내부에서 호출하는 것과 의존성의 관계는 **함수형 프로그래밍에서 중요하지만, 함수 호출 자체가 의존성이라고 간주되지 않습니다**. 중요한 것은 **외부 상태**와 **부작용(side effects)**입니다.

### **함수 호출 vs. 의존성**

- **함수 호출**은 **입력값**만을 사용하고 **출력값을 반환**하는 방식이라면, 순수 함수로 간주됩니다. 이때 함수는 **다른 함수에 의존하지 않고**, 전달받은 인자들만을 기반으로 동작합니다.
- **의존성**이란 **외부 상태**(예: 전역 변수, I/O, 데이터베이스, 파일 시스템 등)에 접근하거나 영향을 미치는 경우에 발생합니다. 즉, 외부 상태를 읽거나 수정하는 것이 의존성이 됩니다.

### **함수를 매개변수로 전달하지 않고 내부에서 호출하는 것에 대해**

함수를 **내부에서 호출**하는 것과 **매개변수로 전달**하는 것의 차이는 **주로 코드의 재사용성**과 **유연성**에 관련이 있습니다. 두 접근 방식 모두 함수형 프로그래밍에서 사용될 수 있으며, 각각의 장단점이 있습니다.

1. **내부에서 호출하는 경우:**

   - **장점:**
     - 코드가 간단하고 직관적일 수 있습니다.
     - 외부에서 함수를 전달받을 필요가 없어서 코드가 덜 복잡할 수 있습니다.
   - **단점:**
     - 다른 함수와의 **재사용성**이 떨어집니다. 같은 로직을 여러 곳에서 사용하려면, 그 함수들을 다시 구현해야 할 수 있습니다.
     - **테스트**가 어려울 수 있습니다. 외부에서 의도적으로 전달되는 함수가 없으므로 테스트 시 의도된 동작을 확인하기 어려울 수 있습니다.

2. **매개변수로 함수를 전달하는 경우 (고차 함수):**
   - **장점:**
     - **재사용성**이 높습니다. 하나의 함수를 다른 곳에서도 사용할 수 있게 되어 코드가 더 모듈화되고 간결해집니다.
     - **테스트**가 용이해집니다. 의도된 로직을 별도의 함수로 전달해주면, 그 함수만 독립적으로 테스트할 수 있습니다.
     - **더 많은 유연성**을 제공합니다. 매개변수로 전달된 함수가 외부에서 바뀌면, 같은 로직에 다른 동작을 쉽게 넣을 수 있습니다.
   - **단점:**
     - 코드가 다소 복잡해질 수 있습니다. 함수의 흐름을 이해하려면, 매개변수로 전달된 함수를 추적해야 하므로 조금 더 신경 써야 할 수 있습니다.
     - **성능**에서 조금 더 overhead가 있을 수 있습니다. 함수 호출이 한 번 더 일어나기 때문에 성능이 중요한 경우에는 신중할 필요가 있습니다.

### **결론:**

- **의존성**은 주로 외부 상태나 부작용에 관련된 것입니다. 함수가 다른 함수를 내부에서 호출하는 것 자체는 의존성이라 볼 수 없습니다.
- 함수를 **매개변수로 전달**하는 것은 **유연성**과 **재사용성**을 높이는 좋은 방법이지만, **필요에 따라 선택**해야 합니다.
  - 단순하고 직관적인 코드가 필요한 경우에는 내부에서 호출하는 것이 더 나을 수 있고,
  - 더 복잡한 로직이나 다양한 조합을 다뤄야 하는 경우에는 고차 함수로 매개변수로 함수를 전달하는 방식이 유리합니다.

따라서, 함수형 프로그래밍에서 **어떤 방식을 사용할지**는 **문제의 복잡도**와 **코드의 재사용성**, **테스트 용이성** 등을 고려해 결정하는 것이 좋습니다.

---

## 🥊 리팩토링

### **기존 코드의 문제점**

1. **불필요한 매개변수 전달**:
   - `isPerfect`, `isAbundant`, `isDeficient` 함수에서 약수 배열과 합을 매개변수로 전달받는 방식은 함수의 의도를 모호하게 만들었고, 매개변수 전달을 더 복잡하게 했습니다.
2. **반복적인 로직**:
   - 약수 배열을 생성하고 그 합을 구하는 작업이 중복되어, 매번 새로운 배열을 생성하고 `reduce`를 사용하여 불필요하게 반복되는 코드가 작성되었습니다.
3. **클로저와 고차함수 미사용**:
   - 클로저와 고차함수를 제대로 활용하지 못해, 반복되는 판별 로직을 재사용할 수 없었습니다.

---

### **리팩토링 후 개선된 점**

#### **index.js**

1. **약수들의 총합을 매개변수로 전달**:

   - `isPerfect`, `isAbundant`, `isDeficient` 함수의 매개변수에서 `sum`과 `factorArray`를 전달받는 방식에서 벗어나, `sum` 값만 전달받도록 변경하여 의도를 더 명확히 했습니다. 이로 인해 불필요한 매개변수 전달이 사라졌습니다.

2. **`equalSet` 함수 함수형 스타일로 변경**:
   - `equalSet` 함수에서 `for`문을 사용하던 방식을 `every()`를 사용하여 함수형 스타일로 리팩토링하여 코드가 더 간결하고 읽기 쉬워졌습니다.

#### **closer.js**

1. **클로저 활용**:

   - 클로저를 활용하여 판별하는 함수를 반환하는 함수를 만들었습니다. 이로 인해 각 숫자에 대한 판별 로직을 반복적으로 재사용할 수 있게 되었으며, 중복을 줄였습니다.

2. **배열을 통한 반복**:

   - 2~100까지의 숫자 배열을 생성한 후, `map()`을 사용하여 각 숫자를 판별하는 함수에 전달하고, 그 결과를 반환하여 출력만 담당하는 함수에 전달했습니다. 이로써 출력 로직과 판별 로직을 명확히 분리했습니다.

3. **고차함수 활용**:

   - `map()`과 같은 고차함수를 적극 활용하여 배열을 반복하면서 판별 로직을 적용하고 결과를 반환하는 구조로 개선했습니다.

4. **책임 분리**:
   - 판별 로직과 출력 로직을 명확히 분리하여, 각 함수가 하나의 책임만을 맡도록 하였습니다. 이는 유지보수성과 가독성을 향상시켰습니다.

---

### **리팩토링 코드 예시**

```javascript
// index.js
const sumOfFactors = (sum) => sum - number;

// 판별 함수들
const isPerfect = (sumOfFactors) => sumOfFactors === number;
const isAbundant = (sumOfFactors) => sumOfFactors > number;
const isDeficient = (sumOfFactors) => sumOfFactors < number;

// closer.js
const createClassifier = (number) => {
  const factorList = factors(number, isFactor);
  const sumOfFactors = sum(factorList);

  return () => ({
    // number,
    perfect: isPerfect(number, sumOfFactors),
    Abundant: isAbundant(number, sumOfFactors),
    deficient: isDeficient(number, sumOfFactors),
    Prime: isPrime(number, factorList, equalSet),
    Square: isSquare(number),
  });
};

const classifyNumbers = (numbers) => {
  return numbers
    .map((number) => {
      const classify = createClassifier(number)();
      const categories = Object.keys(classify)
        .filter((key) => classify[key])
        .join(',');

      return `${number} : ${categories}`;
    })
    .join('\n');
};
```
