# QR 코드 디코딩 미션

## 개발 방향과 의도 정하기

### 이 문제를 해결하기 위해서 나는 어떤 방식에 더 집중할 것인가

**객체지향 프로그래밍 방식 vs 함수형 프로그래밍 방식 vs 하이브리드 방식**

> 기존에 객체지향으로 class를 많이 사용했으니 함수형 프로그래밍 방식에 집중해보자.

### 이 문제를 해결하는 데 어떤 문제 해결 방식으로 접근하는 게 적절한가

> 설계한 흐름은 각각의 함수를 만들고 절차를 따라 진행하는 것이므로 함수형 프로그래밍이 적합해보인다.

```plaintext
입력값 -> 2차원 배열 변환 -> 검증 단계 -> 길이값 읽기 -> 비트 데이터 읽기
-> 2진수를 문자로 변환 -> 에러 코드 추출 및 변환 -> 전체 디코딩
```

### 이 문제를 해결하는 데 필요한 배경 지식, 학습 키워드는 무엇이 있을까

> QR 코드의 데이터 영역과 에러 영역의 구조 분석  
> 2진법과 16진법 변환

- 2진수 ("11001001") → 16진수 ("0xC9") 변환 방법 이해
- 2진수 → 10진수 변환 (`parseInt(bin, 2)`)
- 10진수 → 16진수 변환 (`num.toString(16).toUpperCase()`)

> 비트 조작

- 비트를 읽는 방향과 규칙 이해
- 특정 위치의 비트를 조합해서 숫자로 변환하는 방법
- QR 코드 데이터 해석

### 이 문제를 해결하기 위해서 대충 얼마나 시간이 걸릴까 예상하기

**4시간 예상.**  
당장 하드코딩 방식밖에 생각이 나지 않지만, 그대로 진행한다면 예상 시간이 걸릴 거 같다.

---

## 구현

### 1차 구현

### 1. 패러다임 분석

**절차형 프로그래밍 + 함수형 프로그래밍을 사용했다.**

#### 1. 절차적 프로그래밍

- `main(inputData)` 함수에서 데이터를 처리하는 흐름이 위에서 아래로 순차적으로 진행됨.
- `getArrayFromString`, `validatePattern`, `extractPattern` 등 각각의 기능별로 작은 함수들이 만들어져 있으며, 이 함수들이 절차적으로 호출됨.
- `printValue(value)` 같은 출력 함수가 따로 정의되어 있어, 실행 흐름이 명확함.

#### 2. 함수형 프로그래밍 요소

- `map`, `find`, `join` 등의 배열 메서드를 적극 활용함. (예: `decodeDataString`에서 `.map(convertBinaryToDecimal).map(...)`)
- 함수들이 대부분 순수 함수 형태로 작성됨. (입력값이 동일하면 항상 같은 결과를 반환하며, 내부 상태를 변경하지 않음)
- `getReadFunction(method)` 같은 **고차 함수(higher-order function)** 활용이 있음. (문자열을 받아 적절한 읽기 함수를 반환)

#### 3. 모듈화된 구조

- `input.js`, `readModule.js`, `patterns.js`, `codeMap.js` 등 외부 모듈을 가져와 사용함.
- 읽기 관련 함수(`readUp`, `readDown` 등)를 별도 모듈로 분리하여 관리하고 있음.

#### 4. 객체지향적 요소가 거의 없음

- 클래스를 활용하지 않으며, 데이터와 로직을 객체로 묶어 관리하지 않음.
- `qrCodeArray` 같은 데이터는 함수 호출을 통해 변환하고 가공할 뿐, 상태를 가지는 객체로 다루지 않음.

### 소요시간

**6시간**

#### 왜 예상시간보다 더 걸렸나?

2차원 배열의 `row`, `col`이 `x, y` 좌표랑 반대라서 방향에 따른 읽기 로직 짤 때 많이 헤맸습니다.  
그 로직만 3시간 붙잡고 있었고, 단순하게 생각하지 못한 것이 원인이었습니다.

---

## 피드백

- 개별 함수들이 정리가 안되어있어 가독성이 떨어짐
- CODE_MAP 에서 key를 문자열로 하면 나중에 적용할 때 padStart를 써줘야한다. Map을 사용하면 key로 Number 사용 가능
- class로 관련 함수를 묶거나 파일로 분리 필요

## 리팩토링

### 1. 함수를 그룹화시키자.

아래 처럼 분리해보기

```plaintext
/qrProcessor
 ├── index.js         // main 로직 (entry point)
 ├── parse.js         // 데이터 변환 관련 함수
 ├── validate.js      // 검증 함수
 ├── decode.js        // 디코딩 관련 함수
 ├── utils.js         // 공통 유틸 함수
```

### 함수형 프로그래밍으로만 만들어보자

#### 🚀 문제점 (순수 함수가 아닌 부분)

- **부수효과(Side Effect)**

  - `printValue(value)`에서 `console.log()`를 직접 호출 → 함수형에서는 출력하는 함수와 데이터 생성하는 함수가 분리되어야 함.
  - `main(inputData)`에서 `if (!isStartValid(...) || !isEndValid(...)) return [];` → 함수형에서는 빈 배열 대신 Either 패턴이나 Maybe 패턴을 활용할 수도 있음.

- **가변 상태 사용 (Mutable State)**

  - `getData(inputData, length)`에서 `let result = [];` 사용 → 함수형에서는 `map`을 사용해서 변경 없이 처리해야 함.
  - `getError(inputData)`에서 `let errorArray = [];` 사용 → 이 부분도 `map`을 활용하여 불변성을 유지해야 함.

- **명령형 로직 제거**

  - `for` 루프 사용 (`for (let i = 1; i <= length; i++)` 등) → `map`, `reduce` 등을 사용하여 선언형 코드로 변경

### patterns 데이터 변경 (옵션)

- 현재 배열안의 객체로 선언되어있어서 배열을 순회하는 방식이다.
- 이를 객체로 변환하여 key로 바로 접근이 가능하게 만들어보자
