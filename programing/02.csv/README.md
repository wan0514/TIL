# CSV 미션

# 구현

## 객체와 모듈의 차이는 무엇인가?

SQL 형식의 문장을 반복해서 처리하면서, 데이터를 CSV 파일로 저장하고, 데이터 형식을 따로 관리해야 한다면, **객체와 모듈을 나누는 기준**을 잘 정해야 유지보수하기 좋은 구조를 만들 수 있다.

### **💡 객체 vs. 모듈을 나누는 기준**

| 구분            | 객체 (Object)                                          | 모듈 (Module)                                |
| --------------- | ------------------------------------------------------ | -------------------------------------------- |
| **역할**        | 특정 데이터를 관리하거나 조작                          | 여러 기능을 묶어서 독립적인 코드 단위로 제공 |
| **상태(State)** | 상태를 가지며, 그 상태를 기반으로 동작                 | 보통 상태 없이 함수(유틸리티)를 제공         |
| **재사용성**    | 같은 데이터를 다루는 여러 개의 인스턴스를 만들 수 있음 | 여러 파일에서 import하여 사용                |

---

## **🔍 1. 데이터 관리와 CSV 파일 저장을 어떻게 나눌 것인가?**

- **CSV 파일을 생성하고 저장하는 기능은 모듈로 만들 것인가?**  
  → CSV 파일을 저장하는 기능은 상태를 가질 필요 없이 단순한 함수로 만들 수 있어.  
  → `csvHandler.js` 같은 모듈을 만들어서 `export function saveToCSV()` 같은 방식으로 관리하면 좋음.

- **데이터 자체를 객체로 만들어야 하는가?**  
  → 데이터에는 여러 개의 테이블이 있을 것이고, 각 테이블은 컬럼(데이터 형식)을 관리해야 함.  
  → 이걸 **객체로 만들어서 인스턴스를 관리하는 게 좋음.**  
  → 예를 들어, `Table` 클래스를 만들어서 테이블마다 컬럼과 데이터를 관리하게 할 수 있음.

---

# 기능 구현

## 어떻게 입력값을 분석해서 각각의 기능을 실행할 것인가?

정규식 표현을 이용하여 입력값을 분석하는 함수를 만든다.
분석한 값을 객체로 반환한다. 객체는 명령어마다 구조가 다르다.

```
{ command: 'CREATE', tableName, columns, dataTypes };
{ command: 'INSERT', tableName, columns, values };
{ command: 'DELETE', tableName, condition };
```

해당 객체의 공통 키는 command이며, 이를 통해 어떤 명령인지 switch 문으로
각각의 기능 함수를 실행시킨다.

```
  switch (parsedInput.command) {
    case 'CREATE':
      createFile(parsedInput);
      break;
    case 'INSERT':
      insertToFile(parsedInput);
      break;
    case 'DELETE':
      deleteFrom(parsedInput);
      break;
    default:
      console.log('Unknown command');
  }
```

## 어떻게 칼럼의 dataType과 id값을 저장하고 조회할 것인가?

csv파일을 다루는 모듈과 칼럼 정보를 관리하는 스키마매니저 객채를 따로 구현한다.
추가,삭제 등이 이루어지면 동기화를 시킨다.

1. CsvHanlder.js (CSV 파일을 다루는 모듈)

- CSV 파일 생성
- 데이터 읽기/쓰기
- 칼럼 추가/삭제

2. class Table , Database (테이블 데이터 관리 객체)

- 테이블 생성(Table객체를 만든 후 이를 기반으로 csv파일 생성)
- 칼럼 ID 관리
- 데이터 타입 관리
- 칼럼 추가/삭제

## 실수

### 1. 잘못 파싱된 입력값

원인 : 정규식표현의 캡처 구문을 제대로 작성하지 않아 match[index]로 접근했을 때 다른 값이 들어갔었습니다.

### 2. 테이블이 존재함에도 존재하지 않는 테이블 에러가 발생

원인 : 테이블 존재 여부 함수를 조건문에 넣었으나 !(not 연산자)를 사용하여 함수 반환값이 반대가 되어서, 존재함에도 에러가 발생했었습니다.

# 개선할 점

- 에러 핸들링: 사용자가 입력했을 때 어떤 에러인지 잡아내서 사용자에게 보여줘야 합니다. 현재는 정규표현식으로 포괄적인 에러를 던지는 식으로 구현이 되어있어 개발자와 사용자 모두에게 어떤 에러인지 세세하게 확인하기 어렵습니다.

- fs모듈로 Csv파일 다루기 : 현재 데이터베이스를 class로 만들어서 class의 매서드로 데이터를 업데이트하고, 이를 기반으로 csv파일을 overwirte하는 방식으로 구현했으나, fs모듈의 appendFIle 등의 매서드를 활용하면 database를 구축하지 않고 csv파일과 테이블정보만 담은 객체를 선언하여 구현할 수 있습니다.
