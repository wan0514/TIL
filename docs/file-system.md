# 파일 시스템

## 목차

- 운영체제에서의 파일시스템 필요성
- 파일 시스템의 개념
- FAT12 파일 시스템 구조
- 디렉토리,텍스트파일,바이너리 파일 개념
- 프로그래밍 언어 라이브러리, 시스템 콜, API
- 파일 I/O 프로그래밍 개념

## 1. 운영체제에서 왜 파일 시스템이 필요할까?

운영체제에서 **파일 시스템**이 필요한 이유는 다음과 같습니다:

### 1️⃣ 효율적인 데이터 관리

- 운영체제는 디스크에 저장된 데이터를 **체계적**이고 **효율적으로 관리**해야 합니다. 파일 시스템은 데이터를 **파일 단위**로 나누고, **디렉토리 구조**를 통해 데이터를 조직적으로 저장할 수 있게 해줍니다.

### 2️⃣ 파일 접근 및 저장

- 사용자와 프로그램은 **파일을 저장하고**, **읽고**, **수정하고**, **삭제**하는 작업을 해야 합니다. 파일 시스템은 이러한 작업이 **간편하고 일관성 있게** 이루어지도록 지원합니다.

### 3️⃣ 디스크 공간 관리

- 디스크 공간은 **한정적**이기 때문에, 운영체제는 디스크를 어떻게 **효율적으로 사용할지** 관리해야 합니다. 파일 시스템은 **파일을 저장할 공간을 할당**하고, **여유 공간**을 관리하여 최적화합니다.

### 4️⃣ 파일 구조화

- 운영체제는 파일들을 **디렉토리**라는 **폴더** 안에 구조화하여 **파일의 이름, 위치, 권한 등을 관리**합니다. 이를 통해 사용자는 쉽게 파일을 찾고, 정리할 수 있습니다.

### 5️⃣ 보안 및 권한 관리

- 운영체제는 파일에 대한 **접근 권한**을 설정하고 **보안**을 관리해야 합니다. 파일 시스템은 파일에 대해 **읽기, 쓰기, 실행** 권한을 설정하여 사용자가 **불법적으로 접근하거나 수정**하지 못하도록 보호합니다.

### 6️⃣ 데이터 무결성

- 파일 시스템은 데이터가 손상되지 않도록 **저장**하고, 파일이 삭제되거나 변경될 때 **로그를 기록**하거나 **백업**을 만들어, **데이터 무결성**을 유지합니다.

결국, 파일 시스템은 운영체제에서 **파일을 효율적으로 관리하고**, **파일에 안전하게 접근**하며, **디스크 공간을 최적화**하고, **파일의 보안**을 유지하기 위한 **기본적인 구조**와 **규칙**을 제공합니다.

---

## 2. 파일 시스템의 핵심 개념

### 2️⃣ 파일 시스템이란?

- **정의**: 파일 시스템은 데이터를 저장하고 관리하는 **규칙과 구조**로, 하드디스크나 SSD와 같은 저장 장치에 파일을 저장, 검색, 수정, 삭제하는 역할을 한다.
- **기능**:
  - 파일 저장, 읽기, 삭제, 수정
  - 디스크 공간 관리
  - 디렉토리 구조 관리

---

### 3️⃣ 파일 저장 구조

- **섹터(Sector)**: 디스크의 가장 작은 저장 단위 (ex. 512B, 4KB)
- **블록(Block) / 클러스터(Cluster)**: 여러 섹터를 묶은 단위 (ex. 4KB, 8KB)
  - **블록**: 저장하는 최소 단위
  - **클러스터**: 운영체제마다 명칭이 다를 수 있으며 실질적으로 블록과 같은 의미로 사용됨

#### 파일 저장 방식:

- 파일이 블록보다 크면 **여러 블록에 나뉘어 저장**
- 연속된 공간이 없으면 **파일 조각화(Fragmentation) 발생**
- **파일 조각화**: 연속된 공간이 부족하면 파일이 여러 블록에 분산 저장됨
- **파일 저장 최적화**: 조각 모음(Defragmentation)을 통해 성능을 최적화함

---

### 4️⃣ 파일 조각화와 최적화

- **내부 단편화**: 파일 크기가 블록보다 작을 때 남는 공간 발생
- **외부 단편화**: 여러 블록에 나뉘어 저장되어, 빈 공간을 하나로 모을 수 없을 때 발생
- **조각 모음**: 분산된 파일들을 연속된 블록에 정리하여 성능을 최적화

---

맞습니다, 하위 항목에 대한 마크다운 제목 레벨이 일관되지 않아서 잘못된 구조가 되었습니다. 하위 항목은 `##`보다 한 단계 더 작은 `###`로 시작해야 하므로, 각 하위 항목은 `###` 대신 `####`로 변경해야 합니다. 아래와 같이 수정된 구조를 확인해 주세요:

## 3. FAT12 파일 시스템 구조

### 1️⃣ FAT12 파일 시스템

- **정의**: FAT12는 **파일 할당 테이블(FAT)**을 사용하는 파일 시스템 중 하나로, 12비트의 주소를 사용해 파일을 저장한다. 주로 **구형 저장 장치**에서 사용된다.
- **구조**:
  - **부트 섹터**: 파일 시스템의 시작 지점에 위치하며, FAT 테이블과 데이터 영역 등을 설명하는 정보를 담고 있다.
  - **파일 할당 테이블(FAT)**: 파일이 저장된 위치 정보를 기록하는 테이블로, FAT12에서는 각 파일에 대해 12비트 주소를 사용하여 최대 4,096개의 클러스터를 관리할 수 있다.
  - **데이터 영역**: 실제 파일 데이터가 저장되는 공간이다. 파일 할당 테이블에 의해 데이터가 관리된다.

FAT12(Files Allocation Table 12)는 초기 컴퓨터 시스템에서 사용된 파일 시스템 중 하나로, 12비트의 클러스터 인덱스를 사용하여 디스크에 데이터를 저장하고 관리합니다. FAT12는 DOS 및 초기 버전의 윈도우에서 사용되었으며, 특히 8비트와 16비트 시스템에서 많이 사용되었습니다. FAT12 파일 시스템은 FAT16, FAT32와 같은 후속 시스템에 비해 더 제한적이지만, 여전히 임베디드 시스템 및 플로피 디스크와 같은 작은 디스크에서 사용됩니다.

### 2️⃣ FAT12 파일 시스템 구조

FAT12 파일 시스템은 크게 4가지 주요 구성 요소로 나눌 수 있습니다:

1. **부트 섹터 (Boot Sector)**
2. **파일 할당 테이블 (FAT, File Allocation Table)**
3. **디렉토리 엔트리 (Directory Entries)**
4. **데이터 영역 (Data Area)**

---

#### 부트 섹터 (Boot Sector)

부트 섹터는 FAT12 파일 시스템의 시작 부분에 위치하며, 시스템이 부팅할 때 가장 먼저 읽는 영역입니다. 부트 섹터는 운영 체제 및 하드웨어가 디스크를 올바르게 읽을 수 있도록 필요한 메타데이터와 정보들을 포함하고 있습니다. 이 정보들은 디스크의 크기, FAT의 시작 위치, 섹터 크기, 클러스터 크기, 디스크에서 사용할 수 있는 최대 파일 수 등을 포함합니다.

부트 섹터는 다음과 같은 필드들로 구성됩니다:

- **Jump instruction**: 부트 섹터를 읽은 후 실행할 코드의 시작점.
- **OEM 이름**: 시스템에서 사용된 운영 체제의 이름.
- **BPS (Bytes Per Sector)**: 섹터당 바이트 수.
- **SPC (Sectors Per Cluster)**: 클러스터당 섹터 수.
- **Number of FATs**: FAT 테이블의 수 (FAT12의 경우 항상 2개).
- **Root directory entry count**: 루트 디렉토리에 포함된 최대 파일 수.
- **Sector count**: 전체 섹터 수.
- **FAT size**: FAT 테이블의 크기.
- **Reserved sectors**: 예약된 섹터 수 (일반적으로 1개).

#### 파일 할당 테이블 (FAT)

파일 할당 테이블(FAT)은 디스크의 클러스터가 어떻게 할당되고, 파일이 디스크에 어떻게 저장되는지 추적하는 중요한 데이터 구조입니다. FAT12에서 각 클러스터는 12비트로 주소를 표시합니다. 즉, 각 클러스터는 0부터 2^12-1(4095)까지의 범위에서 주소가 할당됩니다.

FAT는 **클러스터 체인**을 사용하여 파일을 추적합니다. 각 클러스터의 FAT 엔트리는 그 클러스터가 다른 클러스터를 가리키는지, 파일의 끝을 나타내는지 또는 그 클러스터가 비어있는지 등을 나타냅니다. FAT는 다음과 같은 정보를 저장합니다:

- **클러스터 할당 정보**: 각 클러스터가 파일의 일부인지, 또는 다른 클러스터를 가리키는지.
- **끝 클러스터 표시**: 파일의 끝을 나타내는 특수한 값으로, FAT12에서는 `0xFFF`가 파일 끝을 나타냅니다.
- **할당되지 않은 클러스터 표시**: 비어 있는 클러스터를 나타내는 값 (예: `0x000`).

FAT12에서 각 엔트리는 12비트 크기입니다. 이 크기 때문에 FAT12는 상대적으로 작은 디스크 용량에 적합하며, 클러스터 주소를 12비트로 관리할 수 있습니다.

#### 디렉토리 엔트리 (Directory Entries)

디렉토리 엔트리는 디스크의 루트 디렉토리 또는 서브디렉토리에서 각 파일이나 디렉토리에 대한 메타데이터를 저장하는 공간입니다. 각 파일이나 디렉토리는 32바이트 크기의 디렉토리 엔트리로 저장되며, 각 엔트리는 다음과 같은 정보를 포함합니다:

- **파일 이름**: 8.3 포맷(8글자 이름, 3글자 확장자)으로 저장되며, 긴 파일 이름을 지원하려면 특수한 방식으로 저장됩니다.
- **파일 속성**: 읽기 전용, 숨김 파일, 시스템 파일, 디렉토리 등 파일의 속성을 나타냅니다.
- **파일 크기**: 파일의 크기(바이트 단위).
- **클러스터 번호**: 파일 데이터가 저장된 첫 번째 클러스터의 번호.

디렉토리 엔트리에서 중요한 점은 파일의 이름과 속성 외에도 그 파일이 저장된 클러스터의 정보입니다. 이를 통해 운영 체제는 파일을 읽고, 쓰고, 삭제할 수 있습니다.

#### 데이터 영역 (Data Area)

데이터 영역은 실제 파일 데이터가 저장되는 곳입니다. 각 파일은 하나 이상의 클러스터로 나뉘며, 각 클러스터는 디스크에 실제로 데이터를 저장하는 최소 단위입니다. 데이터 영역에는 파일의 내용이 순차적으로 저장되며, FAT가 이 클러스터들을 관리합니다.

---

### 4️⃣ FAT12의 특성

1. **12비트 클러스터 주소**:

   - FAT12는 각 클러스터를 12비트로 관리하므로, 최대 2,048개의 클러스터를 지원할 수 있습니다. 이로 인해 FAT12는 작은 용량의 디스크나 플로피 디스크에 적합합니다.

2. **디스크 크기 제한**:

   - FAT12는 최대 32MB까지 지원하는 경우가 많습니다. 더 큰 용량을 지원하려면 FAT16 또는 FAT32를 사용하는 것이 좋습니다.

3. **성능 제한**:

   - FAT12는 큰 디스크나 파일을 관리할 때 성능이 제한적입니다. 클러스터 주소가 12비트로 제한되어 있기 때문에 대용량 데이터를 효율적으로 처리하는 데 어려움이 있습니다.

4. **파일 크기 제한**:
   - FAT12 파일 시스템에서는 파일 하나의 최대 크기도 클러스터 수에 의해 제한되며, 이론적으로는 32MB 이하의 파일만 지원할 수 있습니다.

### 5️⃣ 결론

FAT12는 작은 디스크에서 파일 시스템으로 효율적으로 동작하지만, 대용량 파일이나 많은 파일을 처리하기에는 제한이 있습니다. 주로 초기의 플로피 디스크나 작은 용량의 하드 디스크에서 사용되었으며, 지금은 거의 사용되지 않지만 일부 임베디드 시스템이나 복고풍의 하드웨어에서 여전히 사용될 수 있습니다.

## 4. 디렉토리, 텍스트 파일, 바이너리 파일 개념 정리

### 1️⃣ 디렉토리 (Directory)

- **정의**: 디렉토리는 파일을 **그룹화**하고 **구성**하는 **폴더**로, 파일을 **정리해서 찾기 쉽게 도와주는 역할**을 한다.
- **기능**:
  - 파일을 분류하여 **관리** (예: 문서, 음악, 사진 등)
  - 하위 디렉토리(폴더) 생성 가능

#### 예시:

- `C:\Users\John\Documents`
- `/home/user/pictures`

#### 간단히 말해:

디렉토리는 **파일들을 정리하는 폴더**로, 파일을 **그룹화**하여 **찾기 쉽게** 만든다.

---

### 2️⃣ 텍스트 파일 (Text File)

- **정의**: 텍스트 파일은 **문자들**만 들어있는 파일로, 사람이 읽을 수 있는 형식이다. 파일 안에 **순수한 텍스트**만 포함되며, 특수한 포맷 없이 **문자들만 나열된** 형태.
- **특징**:
  - **읽기 쉬움**: 메모장 같은 프로그램에서 바로 열어 볼 수 있음
  - **용량이 작다**: 텍스트만 포함되므로 보통 용량이 작음
  - **형식 예시**: `.txt`, `.html`, `.md`

#### 간단히 말해:

텍스트 파일은 **문자만 들어 있는** 파일로, **읽기 쉽고 편집이 간단**하다.

---

### 3️⃣ 바이너리 파일 (Binary File)

- **정의**: 바이너리 파일은 **문자가 아닌 데이터**로 이루어진 파일이다. 숫자, 이미지, 음악, 실행 파일 등 **컴퓨터가 이해할 수 있는 이진 형식**으로 데이터를 저장한다.
- **특징**:
  - **읽기 어려움**: 사람이 읽을 수 없고, 컴퓨터 프로그램을 통해 읽어야 함
  - **용량이 클 수 있음**: 이미지, 오디오, 비디오 등의 데이터가 들어 있기 때문
  - **형식 예시**: `.exe`, `.jpg`, `.mp3`, `.png`

#### 간단히 말해:

바이너리 파일은 **문자가 아닌 컴퓨터만 이해하는 데이터**가 들어있는 파일이다.

---

알겠습니다! 요청하신 대로 각 주제에 대해 상세하게 정리해드리겠습니다. 각 항목을 비슷한 형식으로 정리할게요. 잠시만 기다려 주세요.

---

## 5. 자바스크립트 프로그래밍 언어 라이브러리, 시스템 콜, API

### 1️⃣ 자바스크립트 프로그래밍 언어 라이브러리

- **정의**: 자바스크립트 라이브러리는 자주 사용되는 기능을 모아놓은 코드 모음이다. 이를 통해 개발자는 **반복적인 작업을 피하고**, **효율적으로 개발**할 수 있다.
- **특징**:
  - **기능 제공**: 다양한 유틸리티 함수, DOM 조작, 이벤트 핸들링 등을 제공
  - **주요 예시**:
    - **jQuery**: DOM 조작, 애니메이션, Ajax 요청 등을 간편하게 처리
    - **Lodash**: 배열, 객체, 함수 등을 다루는 유틸리티 함수 제공
    - **Axios**: HTTP 요청을 쉽게 다룰 수 있도록 도와주는 라이브러리

#### 간단히 말해:

라이브러리는 **자주 사용하는 기능들을 미리 구현해놓은** 코드 모음으로, 개발자는 이를 활용해 **빠르고 효율적으로 개발**할 수 있다.

---

### 2️⃣ 시스템 콜 (System Call)

- **정의**: 시스템 콜은 애플리케이션이 운영체제와 상호작용할 수 있도록 해주는 **인터페이스**다. 시스템 콜을 통해 프로그램은 운영체제의 **저수준 기능**에 접근할 수 있다.
- **주요 시스템 콜 종류**:
  - **파일 처리**: `open()`, `read()`, `write()`, `close()`
  - **프로세스 관리**: `fork()`, `exec()`, `wait()`
  - **메모리 관리**: `mmap()`, `munmap()`
  - **네트워크 통신**: `socket()`, `bind()`, `accept()`

#### 간단히 말해:

시스템 콜은 **운영체제의 기능을 프로그램에서 사용할 수 있도록 하는** 인터페이스로, 파일 입출력이나 프로세스 관리 등 **저수준 기능에 접근**한다.

### 터미널에서 시스템 콜을 사용할 수 있나?

터미널에서 시스템 콜을 직접 사용할 수는 없지만, 터미널에서 실행하는 프로그램이나 명령어가 결국 시스템 콜을 사용합니다. 즉, 터미널에서 사용자가 입력하는 명령어들이 내부적으로 운영체제의 시스템 콜을 호출하여 실행되는 것입니다.

### 터미널에서 시스템 콜이 사용되는 예시:

1. **파일 작업**:
   - 예를 들어, `cat`, `ls`, `cp`, `rm` 등의 명령어를 실행하면 이들 명령어가 시스템 콜을 호출하여 파일을 읽거나 쓰고, 파일 목록을 표시하거나, 파일을 삭제하는 등의 작업을 수행합니다.
   - 예를 들어, `cat` 명령어는 내부적으로 `open()`, `read()`, `write()` 시스템 콜을 호출하여 파일을 읽고 터미널에 출력합니다.
2. **프로세스 관리**:
   - `ps`, `top`, `kill` 등의 명령어는 시스템의 프로세스를 조회하거나 종료하는 기능을 제공하는데, 이는 시스템 콜을 통해 수행됩니다. 예를 들어, `ps` 명령어는 `getpid()`, `getppid()` 같은 시스템 콜을 사용하여 프로세스 정보를 얻습니다.
   - `kill` 명령어는 `kill()` 시스템 콜을 사용하여 특정 프로세스를 종료합니다.
3. **네트워크 작업**:
   - `ping`, `curl`, `wget` 등의 네트워크 관련 명령어는 소켓을 생성하고 데이터를 전송하는 과정에서 `socket()`, `connect()`, `send()`, `recv()` 등의 시스템 콜을 사용합니다.

### 시스템 콜을 직접 사용할 수 있는 방법:

터미널에서 **직접 시스템 콜을 호출**할 수는 없지만, 시스템 콜을 사용하는 프로그램을 작성하고 실행할 수 있습니다. 예를 들어, C나 C++ 언어로 시스템 콜을 직접 사용하는 프로그램을 작성하고, 터미널에서 컴파일하여 실행할 수 있습니다.

### 결론:

터미널에서 시스템 콜을 "직접" 사용한다기보다는, 터미널에서 실행되는 프로그램이나 명령어가 내부적으로 시스템 콜을 호출하여 작업을 수행합니다. 시스템 콜을 직접 사용하고 싶다면, C와 같은 저수준 언어로 프로그램을 작성하고 실행해야 합니다.

---

### 3️⃣ API (Application Programming Interface)

- **정의**: API는 **소프트웨어 구성 요소들이 서로 상호작용**할 수 있도록 제공되는 인터페이스이다. API는 함수나 메서드 집합으로 제공되어, 다른 프로그램이 기능을 호출하고 사용할 수 있게 한다.
- **특징**:
  - **웹 API**: HTTP를 통해 외부 서비스와 통신 (예: REST API, GraphQL API)
  - **라이브러리 API**: 특정 기능을 제공하는 코드 집합 (예: 자바스크립트 DOM API)
  - **시스템 API**: 운영체제와 상호작용하는 기능을 제공 (예: 윈도우 API)

#### 간단히 말해:

API는 **소프트웨어 간의 상호작용을 가능하게 하는** 인터페이스로, 외부 기능을 호출하여 **프로그램 기능을 확장**할 수 있게 한다.

---

## 6. 파일 I/O 프로그래밍 개념

### 1️⃣ 파일 I/O (입력/출력) 프로그래밍

- **정의**: 파일 I/O는 **파일과 프로그램 간의 데이터 읽기 및 쓰기 작업**을 다룬다. 이를 통해 데이터를 디스크에 저장하거나, 디스크에서 데이터를 읽어들여 프로그램에서 사용할 수 있다.
- **파일 I/O 작업**:
  - **파일 열기**: 파일을 읽거나 쓰기 위해 열기 (예: `open()`, `fopen()`)
  - **데이터 읽기**: 파일에서 데이터를 읽어오기 (예: `read()`, `fread()`)
  - **데이터 쓰기**: 파일에 데이터를 저장하기 (예: `write()`, `fprintf()`)
  - **파일 닫기**: 작업을 마친 후 파일을 닫기 (예: `close()`, `fclose()`)

#### 간단히 말해:

파일 I/O는 **파일에서 데이터를 읽고, 파일에 데이터를 저장하는 작업**으로, 데이터를 **영구적으로 저장**하거나 **다시 사용할 수 있게 한다**.

---

### 2️⃣ 파일 처리 방식

- **동기적 I/O**: 프로그램이 파일을 읽거나 쓸 때 작업이 완료될 때까지 기다린 후 다음 작업을 진행하는 방식.
- **비동기적 I/O**: 파일 작업을 요청한 후, 작업이 완료되지 않아도 다른 작업을 진행할 수 있는 방식.

---
